(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{419:function(s,t,a){"use strict";a.r(t);var r=a(2),o=Object(r.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[s._v("#")]),s._v(" 简介")]),s._v(" "),t("p",[s._v("今天偶尔逛掘金的时候发现一篇面经的文章是一个两年的面试，里面有提及到面试官细问dom树的生成过程区别于一般的浅显的提问，这个问的比较深入一点，涉及到了js和css怎么影响dom树构建和渲染，经过反复看了几遍终于看明白了，晚上做一个总结性的记录加强印象")]),s._v(" "),t("h2",{attrs:{id:"_1-关于dom树的生成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-关于dom树的生成"}},[s._v("#")]),s._v(" 1.关于dom树的生成")]),s._v(" "),t("p",[s._v("想到dom树的生成过程第一个想到的是一个个节点构成的dom树结构，那么就会想到节点是怎么连成树的，进而想到那么节点是怎么来的呢，这就用到了一个类似于词法分析器的一个东西叫"),t("strong",[s._v("html")]),s._v("解析器\n，当然他也是词法分析的功能，它会一边加载html文档一边进行解析得到一个个节点"),t("br"),s._v('\n整体过程是，网络进程收到响应头里面的"content-type"字段后知道请求文件的类型，如果是"text/html"那么浏览器就知道这是一个html文档了，所以创建一个渲染进程然后，网络进程会和这个渲染进程之间建立一个管道，这样数据通过管道从网络进程流向渲染进程流进html解析器')]),s._v(" "),t("p",[t("em",[t("strong",[s._v("解析器具体的解析过程")])]),t("br"),s._v("\n解析器首先接收字节流然后会把字节流\n类似于之前在力扣做的一个括号匹配算法题，原理是利用一个栈。在解析html文档时在dom树中创建一个节点如果是文本就是文本节点，并且这个节点的父节点就是目前栈顶的节点，如果是个starttag那就把starttag压入栈中，如果是个endtag那就stack.pop()弹出去栈顶元素反复重复上述过程最后可以得到一个dom树")]),s._v(" "),t("h2",{attrs:{id:"_2-js和css对于dom树解析和构建的影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-js和css对于dom树解析和构建的影响"}},[s._v("#")]),s._v(" 2.js和css对于dom树解析和构建的影响")]),s._v(" "),t("p",[s._v("像如果刚才在解析构建dom树时，body标签里面出现了script，也就是压栈时遇到了script此时，html解析器就会停止工作，让位给js引擎，js引擎去执行一些操作，执行完毕后返回来再重新进行dom树的构建"),t("br"),s._v("\n如果是通过外链接链接的js文件，那么情况又是不一样的，chromev8引擎做了优化，就是可以提前知道有哪些js文件或者css文件需要用到提前下载，所以当html解析到一半dom没有构建完毕的时候，会因为js文件或者css文件的下载而停止下来去下载文件，这个下载文件时间按最长的一个时间算，下载完毕后会构建cssom和执行js（js一定会在cssom构建完之后执行因为js可能会操作cssom所以js依赖于cssom）js执行完毕后会继续构建dom树了")]),s._v(" "),t("h3",{attrs:{id:"_3-关于async和defer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-关于async和defer"}},[s._v("#")]),s._v(" 3.关于async和defer")]),s._v(" "),t("p",[s._v("async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前")]),s._v(" "),t("p",[s._v("defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机在DOMContentLoaded事件派发之前")]),s._v(" "),t("h2",{attrs:{id:"_4-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-总结"}},[s._v("#")]),s._v(" 4.总结")]),s._v(" "),t("p",[s._v("css不会阻塞dom树的解析，但是会影响js运行，而js运行会阻塞dom树的解析"),t("br"),s._v("\ncss会阻塞render tree的生成进而影响dom的渲染"),t("br"),s._v("\n今天写了点毕设")])])}),[],!1,null,null,null);t.default=o.exports}}]);