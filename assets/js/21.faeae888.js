(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{431:function(t,a,e){"use strict";e.r(a);var s=e(2),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("p",[t._v("读红宝书js垃圾回收机制和性能优化加内存管理三部分后个人理解。")]),t._v(" "),a("h2",{attrs:{id:"js垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js垃圾回收"}},[t._v("#")]),t._v(" js垃圾回收")]),t._v(" "),a("p",[t._v("js垃圾回收一般是两种：标记清除、引用计数。"),a("br"),t._v("\n标记清除是在一个变量进入上下文的时候对他做出标记知道他进入出的时候取消标记。实现的方式可以不同，但是大概意思是用标记区分在上下文和不再上下文的变量。一种实现方式是开始的时候就给所有的变量标记，然后只要有变量进入上下文就取消他身上的标记，这样没标记的都会在下一轮被清理。"),a("br"),t._v("\n引用计数是当一个变量被初始化或者被其他变量引用的时候计数加一，如果变量被其他的覆盖了计数减一，但是有个问题就是循环引用，对象A属性指向对象B，对象B属性指向对象A那么他们就相互引用计数为2不会清除。(IE8以及更早版本的IE浏览器DOM，BOM对象使用C++语言实现的，他们都是引用计数的形式，所以会出现上述的循环引用的情况，解决办法就是手动在后面赋值为null)")]),t._v(" "),a("h2",{attrs:{id:"性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),a("p",[t._v("垃圾回收程序是周期性运行的，如果内存中分配了较多的变量则有可能造成性能损失，所以垃圾回收的时间调度很重要，一个原则是不论什么时候收集垃圾都要让他能够较快的结束。"),a("br"),t._v("\n现代垃圾回收程序一般都是根据js运行时环境来探测何时运行的。比如IE7js垃圾回收机制是这样的，他会动态改变分配变量，字面量或数组槽位等会触发垃圾回收机制的阈值，如果垃圾回收程序回收的内存还达不到已分配的15%就让这个阈值翻倍(我的理解是你回收一次的内存才不到分配的15%就说明分配的内存很够用不用这么频繁的触发垃圾回收所以要提高阈值)，当某次回收的内存占到85%则阈值要回复到默认值，(说明要快一点回收了)")]),t._v(" "),a("h2",{attrs:{id:"内存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),a("p",[t._v("优化内存的目的是为了避免运行大量js的网页耗尽系统内存而导致操作系统崩溃，这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。将内存占用尽量小可以让页面性能够好。"),a("br"),t._v("\n优化的最佳手段就是只保存必要的数据，如果数据不是必要了，就要设置为null从而释放。"),a("br"),t._v("\n还有两种具体的方式提升性能：")]),t._v(" "),a("h3",{attrs:{id:"_1-通过const和let声明提升性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-通过const和let声明提升性能"}},[t._v("#")]),t._v(" 1.通过const和let声明提升性能")]),t._v(" "),a("p",[t._v("因为let、const都是块级作用域，而我们的优化的目的就是为了让垃圾的内存尽可能快的回收，而块级作用域通常会比函数作用域更早终止。")]),t._v(" "),a("h3",{attrs:{id:"_2-隐藏类和删除操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-隐藏类和删除操作"}},[t._v("#")]),t._v(" 2.隐藏类和删除操作")]),t._v(" "),a("p",[t._v("如chorme浏览器v8引擎，将解释后的js代码编译为实际的机器码时会利用隐藏类来达到复用的目的。"),a("br"),t._v("\n比如")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Article(){\n    this.title = 'lllllll'\n}\nlet a1 = new Article()\nlet a2 = new Article()\n")])])]),a("p",[t._v("这两个实例共享同一个构造函数和原型，这样的话其实就是有一样的隐藏类。但是假如上面的代码创建后，我又给a1加了个属性，那么他们就不会在共享一个隐藏类了，同理使用delete a1.some 删除a1的some属性后，他们也是不具有同样的隐藏类了，最好的办法就是都有some属性然后给a2的some设置为null。")]),t._v(" "),a("h2",{attrs:{id:"内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[t._v("#")]),t._v(" 内存泄漏")]),t._v(" "),a("p",[t._v("内存泄漏一般由一下几种情况引起。")]),t._v(" "),a("h3",{attrs:{id:"未声明变量就使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#未声明变量就使用"}},[t._v("#")]),t._v(" 未声明变量就使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function setName(){\n    name = 'Jack'\n}\n")])])]),a("p",[t._v("这样name就挂到window了，window不消失name不消失")]),t._v(" "),a("h3",{attrs:{id:"定时器形成了闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时器形成了闭包"}},[t._v("#")]),t._v(" 定时器形成了闭包")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let name = 'Jack'\nsetInterval(()=>{\n    console.log(name)\n},100)\n")])])]),a("p",[t._v("定时器内部引用了外面的jack，只要定时器一直运行，name就一直占用内存。")]),t._v(" "),a("h3",{attrs:{id:"闭包泄露内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包泄露内存"}},[t._v("#")]),t._v(" 闭包泄露内存")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let outer = function() { \n let name = 'Jake'\n return function() { \n return name\n }\n}\n")])])]),a("p",[t._v("如果里面的函数存在就不会清理name，因为闭包一直在引用它")]),t._v(" "),a("h2",{attrs:{id:"静态分配和对象池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态分配和对象池"}},[t._v("#")]),t._v(" 静态分配和对象池")]),t._v(" "),a("p",[t._v("避免多余的垃圾回收是提升js性能的关键。要知道浏览器决定何时运行垃圾回收程序的一个标准就是对象的更替速度，加入有很多的对象被初始化后一下子超出作用域，那么浏览器一看哎呀小子搞这个东西，浏览器直接就是加大火力调用垃圾回收这样就会影响性能，比如这样的计算二位矢量加法的函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function addVector(a,b){\n    let resultant = new Vector(); \n    resultant.x = a.x + b.x; \n    resultant.y = a.y + b.y; \n    return resultant; \n}\n")])])]),a("p",[t._v("假如这个函数被频繁的调用，比如一个for循环我调用了几十次，那么浏览器一看哎那么可要触发回收机制了，你就卡着去吧。解决这个问题的方法是，提前在外面我创建一个对象，然后我在函数里面改属性就好了。"),a("br"),t._v("\n对象池就是针对这种情景的解决方案。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。\n应用程序可以向这个对象池请求一个对象、设置其属性、用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let v1 = vectorPool.allocate()\nlet v2 = vectorPool.allocate()\nlet v3 = vectorPool.allocate()\nv1.x = 10\nv1.y = 5\nv2.x = -3\nv2.y = -6\naddVector(v1, v2, v3)\nconsole.log([v3.x, v3.y]); // [7, -1] \nvectorPool.free(v1)\nvectorPool.free(v2)\nvectorPool.free(v3) \n// 如果对象有属性引用了其他对象\n// 则这里也需要把这些属性设置为 null \nv1 = null\nv2 = null\nv3 = null\n")])])]),a("p",[t._v("对象池的结构，数组是个比较好的选择，但是js数组大小动态可变一般来说引擎会删除大小为100的数组再创建大小为200的数组，垃圾回收程序会识别删除这个动作，他就会再来执行一次回收，所以说要事先想好这个对象池要多大，初始化的时候就尽量创建一个够用的数组。")])])}),[],!1,null,null,null);a.default=n.exports}}]);