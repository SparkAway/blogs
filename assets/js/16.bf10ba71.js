(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{418:function(t,e,l){"use strict";l.r(e);var n=l(2),a=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[t._v("工作中因为经常用到el-table表格展示数据，我们都知道可以给el-table设置一个宽度百分百然后那些列不设置宽度他们就会自动去补，设置宽度的就按设置的宽度来，但是一旦一个表格的列数很多我们不得不做一个妥协就是overflow的时候显示tooltip，但是这样展示出的表格有点丑而且不能一眼就看清数据，那可不可以有一种做法就是能在一行显示全数据并且可以允许表格左右拉动滚动条，有一个问题就是我们怎么知道一列数据的宽度该设置为多少呢？其实只要知道最大宽度然后其它本列的都按照最大的来就可以了，所以想到根据获取到的数据来动态计算出列宽然后赋值就可以了。")]),t._v(" "),e("h2",{attrs:{id:"_1-自定义指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-自定义指令"}},[t._v("#")]),t._v(" 1.自定义指令")]),t._v(" "),e("p",[t._v("说干就干要想设置这些列宽首先需要知道el-table中显示这些数据的单元格在哪，打开f12后查看dom结构。会发现el-table是用上下两个原生的table表格来实现的，打开原生table结构发现每个th或者td块的class都对应着colgroup中的name字段，所以可以通过获取table表格下的colgroup然后拿到所有的col，然后遍历col，并且用col中的name去table中查和name一样的class的th和td的所有块，然后形成个数组cells代表col这一列所有的单元格，然后去查询每个单元格的宽度然后获取最大值，然后把这列col的width设置为最大值。")]),t._v(" "),e("p",[t._v("为什么会想到用自定义指令？因为这种表格的自适应是很常见的有几个表就要用几次而且它的逻辑是修改dom也很适合封装到自定义指令中")]),t._v(" "),e("p",[t._v("代码如下:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import './style.css'\nfunction adjustColumnWidth(table) {\n  table.classList.add('r-table')\n  const colgroup = table.querySelector('colgroup')\n  const colDefs = [...colgroup.querySelectorAll('col')]\n  colDefs.forEach((col) => {\n    const clsName = col.getAttribute('name')\n    const cells = [\n      ...table.querySelectorAll(`td.${clsName}`),\n      ...table.querySelectorAll(`th.${clsName}`)\n    ]\n    if (cells[0]?.classList?.contains?.('leave-alone')) {\n      return\n    }\n    const widthList = cells.map((el) => {\n      return el.querySelector('.cell')?.scrollWidth || 0\n    })\n    const max = Math.max(...widthList)\n    table.querySelectorAll(`col[name=${clsName}]`).forEach((el) => {\n      el.setAttribute('width', max)\n    })\n  })\n}\nexport default {\n  bind(el) {\n  },\n  update(el) {\n  },\n  inserted(el) {\n  },\n\n  // 同步第一次无效的原因可能是由于计算需要的数据的宽度此时还没有，因为获取数据\n  // 是一个微任务操作，而浏览器运行机制是刚开始script作为一个宏任务执行，\n  // 然后执行内部的同步任务，然后将微任务放入为微任务队列，宏任务放入红任务队列\n  // 执行完大的宏任务后执行微任务然后执行浏览器UI进程的渲染工作\n  // 所以当我们用微任务的时候第一次就可以了，因为我们在微任务获取数据后又加了一个\n  // 用来改变表格宽度的微任务，然后进行了UI渲染，所以可以第一次就刷新\n  // 而宏任务会进入第二轮的上述循环也可以实现渲染\n\n  // 这里有个bug，就是当我点击一个什么东西弹出了个el-dialog后会引起浏览器重排\n  // 然后自动适应宽度就会失效，经过检查后发现可能是因为弹出el-dialog后会去改变\n  // body它会给body加上padding-right:17px的偏移值 导致了位置发生了变化引起了重排\n  // 解决办法就是想办法不让body偏移\n  // 1.:lock-scroll=\"false\"放在dialog上面\n  // 2.在main.js中Element.Dialog.props.lockScroll.default = false;\n  componentUpdated(el, binding, vnode, oldVnode) {\n    console.log('Vnode更新了')\n    setTimeout(() => {\n      adjustColumnWidth(el)\n    }, 0)\n  },\n  unbind() {}\n}\n")])])]),e("p",[t._v("然后在index.js中输入以下代码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import fitColumns from './fitColumns'\n\nconst install = function(Vue) {\n  Vue.directive('fitColumns', fitColumns)\n}\n\nif (window.Vue) {\n  window.fitColumns = fitColumns\n  Vue.use(install) // eslint-disable-line\n}\n\nfitColumns.install = install\nexport default fitColumns\n\n")])])]),e("h2",{attrs:{id:"如何使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何使用"}},[t._v("#")]),t._v(" 如何使用")]),t._v(" "),e("p",[t._v("在要使用的页面中")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<el-table v-fitColumns>\n\n</el-table>\n...\nimport fitColumns from '@/directive/fit-columns/index'\nexport default{\n    directive:{\n        fitColumns\n    }\n}\n")])])]),e("h2",{attrs:{id:"引发的思考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引发的思考"}},[t._v("#")]),t._v(" 引发的思考")]),t._v(" "),e("h3",{attrs:{id:"_1-关于浏览器重排和重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-关于浏览器重排和重绘"}},[t._v("#")]),t._v(" 1.关于浏览器重排和重绘")]),t._v(" "),e("p",[t._v("因为这次的需求有涉及到更改dom元素的宽度所以肯定会触发重排，那么重排触发的条件是什么?"),e("br"),t._v("\n1.页面初始渲染时(无法避免)"),e("br"),t._v("\n2.浏览器窗口改变尺寸"),e("br"),t._v("\n3.元素位置改变 （margin position)\n4.元素尺寸改变   (padding,border)\n5.元素内容改变"),e("br"),t._v("\n6.添加或删除可见dom元素"),e("br"),t._v("\n7.获取尺寸信息offsetTop、getComputedStyle等"),e("br"),t._v("\n重绘就是visibility、outline、背景色"),e("br"),t._v("\n重排是很'贵'的操作，所以要减少重排，浏览器本身也不会修改一次就重排一次他是会有个缓冲队列，队列排满了然后排一次，有点类似于事件循环。"),e("br"),t._v("\n其他能减少重排的操作:文档碎片，先displaynone然后改完了再display回来，设置为absolute或者fixed让它脱离文档流。")]),t._v(" "),e("h3",{attrs:{id:"_2-事件循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件循环"}},[t._v("#")]),t._v(" 2.事件循环")]),t._v(" "),e("p",[t._v("一般顺序是刚开始script作为一个宏任务执行，然后执行内部的同步任务，然后将微任务放入为微任务队列，宏任务放入红任务队列，执行完大的宏任务后执行微任务然后执行浏览器UI进程的渲染工作，然后执行完毕后循环往复。"),e("br"),t._v("\n记住UI的渲染是在微任务进行完之后进行的。")]),t._v(" "),e("h3",{attrs:{id:"_3-bug问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-bug问题"}},[t._v("#")]),t._v(" 3.bug问题")]),t._v(" "),e("p",[t._v("刚开始进去自动适应解决了，但是点击了弹窗后发现适应不了，想到会不会是弹窗出发了重排，打开f12后发现打开el-dialog后会给body添加padding-right的属性正好触发了重排，所以解决方案是不让他添加，有两种办法，一种全局一种局部。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('//1.:lock-scroll="false"放在dialog上面\n//2.在main.js中Element.Dialog.props.lockScroll.default = false;\n')])])]),e("h3",{attrs:{id:"不足"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不足"}},[t._v("#")]),t._v(" 不足")]),t._v(" "),e("p",[t._v("现在无法根据页面尺寸变化动态调整等待后续更新。。。。。。。。")])])}),[],!1,null,null,null);e.default=a.exports}}]);