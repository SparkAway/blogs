(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{430:function(e,n,d){"use strict";d.r(n);var t=d(2),o=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),n("p",[e._v("由于最近工作用vue2框架比较多，各种用法操作越来越熟练，但是再熟练也只是熟练工，掌握内部原理才是工程师应该有的水准。")]),e._v(" "),n("h2",{attrs:{id:"为什么会用到diff算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么会用到diff算法"}},[e._v("#")]),e._v(" 为什么会用到diff算法")]),e._v(" "),n("p",[e._v("首先由之前我看到的vue2源码知道，vue2是把模板翻译为了render函数，而render函数可以生成Vnode也就是虚拟dom，然后通过update(render())生成真实的dom，所以再进入update里面，发现update位于lifecycle文件里面，在lifecycle文件里面会对update混入vue原型对象，然后发现里面的核心代码其实是这个")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("if (!prevVnode) {\n    // 老 VNode 不存在，表示首次渲染，即初始化页面时走这里\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n} else {\n    // 响应式数据更新时，即更新页面时走这里\n    vm.$el = vm.__patch__(prevVnode, vnode)\n}\n")])])]),n("p",[e._v("那么继续点击__patch__发现点不动因为__patch__是被挂载到vue原型对象上的，查阅后发现因为vue的节点更新是根据不同平台来的，所以它在platforms/web/runtime/index中被挂载到原型对象上，再追下去发现他在patch文件中有一个操作，\n"),n("code",[e._v("export const patch: Function = createPatchFunction({ nodeOps, modules })")]),e._v("\n这句代码运用到了高阶函数，createPatchFunction点进去后发现它会在内部做一些操作，然后返回一个函数，这个函数参数接受两个一个是旧的vnode一个是新的vnode，但是对于外部外部并不知道中间还有加了一部处理的这个操作，这中高阶函数的操作我觉得有必要学会应用。"),n("br"),e._v("\n点进去后发现这个函数非常的大并且内部做了很多的操作，(这是在函数内部创建了很多函数，最后返回函数和之前看的函数式编程思想不谋而合，而且这种思路很适合类似JSX语法的vue3组合式api)"),n("br"),e._v("\n直接看返回的patch函数，在patch函数中有这样一段代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("if (!isRealElement && sameVnode(oldVnode, vnode)) {\n    // 不是真实元素，但是老节点和新节点是同一个节点，则是更新阶段，执行 patch 更新节点\n    patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)\n}\n\n...\nfunction sameVnode (a, b) {\n  return (\n    // key 必须相同，需要注意的是 undefined === undefined => true\n    a.key === b.key && (\n      (\n        // 标签相同\n        a.tag === b.tag &&\n        // 都是注释节点\n        a.isComment === b.isComment &&\n        // 都有 data 属性\n        isDef(a.data) === isDef(b.data) &&\n        // input 标签的情况\n        sameInputType(a, b)\n      ) || (\n        // 异步占位符节点\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\n")])])]),n("p",[e._v("samenode是比较同key，同tag，同有data值(至于为什么只看有没有而不看一不一样一会就知道)，然后如果是一样的节点，那么执行patchVnode方法传进去新旧节点。😮等等。。。比较不同，"),n("s",[e._v("这难道就是传说中的diff吗")]),e._v("没错，diff就是这样来的。")]),e._v(" "),n("h2",{attrs:{id:"diff具体做了什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff具体做了什么"}},[e._v("#")]),e._v(" diff具体做了什么")]),e._v(" "),n("p",[e._v("我们继续点击patchVnode方法，我们先不关注其它的东西，先看这一句")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("if (isDef(oldCh) && isDef(ch)) {\n    // 如果新老节点都有孩子，则递归执行 diff 过程\n    if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n} \n")])])]),n("p",[e._v("这是一句很明显的递归，继续点击updateChildren函数发现")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    老节点的开始索引\n    let oldStartIdx = 0\n    // 新节点的开始索引\n    let newStartIdx = 0\n    // 老节点的结束索引\n    let oldEndIdx = oldCh.length - 1\n    // 第一个老节点\n    let oldStartVnode = oldCh[0]\n    // 最后一个老节点\n    let oldEndVnode = oldCh[oldEndIdx]\n    // 新节点的结束索引\n    let newEndIdx = newCh.length - 1\n    // 第一个新节点\n    let newStartVnode = newCh[0]\n    // 最后一个新节点\n    let newEndVnode = newCh[newEndIdx]\n")])])]),n("p",[e._v("这不就是之前我们没看过vue2源码的时候死记硬背的那个vue2diff算法的双端队列吗，我们赶紧看看它接下来的操作。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        // 如果节点被移动，在当前索引上可能不存在，检测这种情况，如果节点不存在则调整索引\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        // 老开始节点和新开始节点是同一个节点，执行 patch\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        // patch 结束后老开始和新开始的索引分别加 1\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        // 老结束和新结束是同一个节点，执行 patch\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        // patch 结束后老结束和新结束的索引分别减 1\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        // 老开始和新结束是同一个节点，执行 patch\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        // 处理被 transtion-group 包裹的组件时使用\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        // patch 结束后老开始索引加 1，新结束索引减 1\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        // 老结束和新开始是同一个节点，执行 patch\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        // patch 结束后，老结束的索引减 1，新开始的索引加 1\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        // 如果上面的四种假设都不成立，则通过遍历找到新开始节点在老节点中的位置索引\n\n        // 找到老节点中每个节点 key 和 索引之间的关系映射 => oldKeyToIdx = { key1: idx1, ... }\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        // 在映射中找到新开始节点在老节点中的位置索引\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        if (isUndef(idxInOld)) { // New element\n          // 在老节点中没找到新开始节点，则说明是新创建的元素，执行创建\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          // 在老节点中找到新开始节点了\n          vnodeToMove = oldCh[idxInOld]\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            // 如果这两个节点是同一个，则执行 patch\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n            // patch 结束后将该老节点置为 undefined\n            oldCh[idxInOld] = undefined\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // 最后这种情况是，找到节点了，但是发现两个节点不是同一个节点，则视为新元素，执行创建\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        // 老节点向后移动一个\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n")])])]),n("p",[e._v("所以分为以下几种情况:"),n("br"),e._v("\n1.当前oldstart指向的节点是空的，就让oldstart的节点索引向右移动一位"),n("br"),e._v("\n2.当前oldend指向的节点为空，就让oldend的节点索引左移一位"),n("br"),e._v("\n3.如果老开始和新开始一样就索引都右移一位"),n("br"),e._v("\n4.如果老结束和新结束一样就索引左移一位"),n("br"),e._v("\n5.如果老开始和新结束一样，就把老开始的节点换到老结束后面，并且老开始的索引加一，新结束索引左移一位"),n("br"),e._v("\n6.如果老结束和新开始一样，就把老结束的节点换到新开始前面，并且老结束的索引减一，新开始索引右移一位"),n("br"),e._v("\n7.以上几种情况都不符合就，就遍历找到新开始在老开始结束之间的位置，如果那个位置的节点和新开始是一个节点就把那个位置的节点换到老开始前面，并把原来节点的置为空，然后新开始索引右移一位，不然就新创建一个节点，然后新节点右移一位"),n("br"),e._v("\n8.如果没找到就说明是新的节点，直接创建就好了。")])])}),[],!1,null,null,null);n.default=o.exports}}]);