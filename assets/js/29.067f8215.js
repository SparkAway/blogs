(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{427:function(e,t,a){"use strict";a.r(t);var r=a(2),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),t("p",[e._v('经常有考到v-model双向绑定，虽然知道它是v-bind:value和v-on:input="value=$event.target.value""的语法糖。但是为什么能实现这些指令还是不知道的，因为原生的html上并没有v-bind v-on这些指令，联想到之前学的vue会把模板编译为render函数然后render函数生成虚拟dom，所以应该是在模板编译这一步骤完成的指令的翻译，所以关注模板翻译就好。')]),e._v(" "),t("h2",{attrs:{id:"模板翻译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板翻译"}},[e._v("#")]),e._v(" 模板翻译")]),e._v(" "),t("p",[e._v("模板翻译过程发生了什么呢？模板字符串通过正则和算法得到抽象语法树，然后抽象语法树通过字符串拼接得到render函数。")]),e._v(" "),t("h2",{attrs:{id:"来源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#来源"}},[e._v("#")]),e._v(" 来源")]),e._v(" "),t("p",[e._v("点击render后发现render函数是通过compileToFuctions函数得来的，在调用compileToFuctions后生成了一堆很长的字符串，里面有包含s(msg)这种就是动态数据了，生成render的时候不会变成数据，但是当调用render生成虚拟dom的时候s(msg)就会被替换为数据。"),t("br"),e._v("\n在src/complier/index中找到以下代码:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const ast = parse(template.trim(), options)\nif (options.optimize !== false) {\n    optimize(ast, options)\n}\nconst code = generate(ast, options)\nreturn {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n}\n")])])]),t("p",[e._v("说明parse函数会接收vue文件中的template模板并进行转换生成抽象语法树，然后通过generate函数接收抽象语法树生成render函数。最终返回抽象语法树和render函数(这里在最后返回了一个对象，所以在别的页面用到的时候可以直接解构赋值取出里面包含的内容，这点值得学习)")]),e._v(" "),t("h2",{attrs:{id:"parse函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parse函数"}},[e._v("#")]),e._v(" parse函数")]),e._v(" "),t("p",[e._v("parse函数做了什么?parse函数很大，但parse函数包括三个函数和一个引入的parseHTML，warnonce函数主要功能是发出警告，closeELement函数主要功能是关闭标签，trimEndingWhitespace函数的主要功能是去除掉关闭标签之前的空格，parseHTML函数的选项传入了四个函数，分别是start、end、chars、comment。"),t("br"),e._v("\nstart的作用是遇到开始标签时处理属性、指令，属性开始和结束的位置信息添加rawAttrsMap属性，处理v-for、v-if、v-once，如果类似与input还要做闭合处理。"),t("br"),e._v("\nend的作用是从stack栈中移除一个节点关闭处理，调用closeElement。"),t("br"),e._v("\nchars的作用是检验空root，处理文字，处理插值表达式，但是最终还是要调用parseText"),t("br"),e._v("\ncomment的作用是处理注释。")]),e._v(" "),t("h2",{attrs:{id:"parsehtml函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parsehtml函数"}},[e._v("#")]),e._v(" parseHTML函数")]),e._v(" "),t("p",[e._v("点进去parseHTML函数后发现多处用到前进函数advance")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function advance (n) {\n   index += n;\n   html = html.substring(n);\n}\n")])])]),t("p",[e._v("它的作用是截取模板字符串。")]),e._v(" "),t("h2",{attrs:{id:"parsestarttag函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parsestarttag函数"}},[e._v("#")]),e._v(" parseStartTag函数")]),e._v(" "),t("p",[e._v("这个函数会匹配到<然后会把节点的属性什么的都挂到match上")]),e._v(" "),t("h2",{attrs:{id:"parseendtag函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parseendtag函数"}},[e._v("#")]),e._v(" parseEndTag函数")]),e._v(" "),t("p",[e._v("这个函数会匹配到>之后会调用options.end()方法，本质上是执行end()方法从栈中移除一位，然后结束标签调用closeElment()方法。")]),e._v(" "),t("h2",{attrs:{id:"handlestarttag函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#handlestarttag函数"}},[e._v("#")]),e._v(" handleStartTag函数")]),e._v(" "),t("p",[e._v("这个函数会将匹配好的结果整理为属性数组attrs然后调用options.start方法")]),e._v(" "),t("h2",{attrs:{id:"generate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generate"}},[e._v("#")]),e._v(" generate")]),e._v(" "),t("p",[e._v("然后需要通过generate来放入ast然后生成render函数"),t("br"),e._v("\n实际上generate是调用了genElement,点进去看到genELment的判断顺序为el.once>el.for>el.if>el.tag='templage'>el.tag='slot',(这就是为什么尽量不要把v-for和v-if放在同一个元素里面的原因)。然后会走genData把id:root提取到attrs，然后走genChildren最后用code方法把他们拼接起来")])])}),[],!1,null,null,null);t.default=s.exports}}]);