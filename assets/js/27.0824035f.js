(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{423:function(t,e,r){"use strict";r.r(e);var s=r(2),a=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[t._v("写代码的过程中发现了以前的代码用到Object.assign({},defaultObj)来创建对象，经过查阅后发现object.assign只会把后面那个对象的keyvalue都复制到前面的对象里面,object.assign({},obj1,obj2)后面的对象里面相同的属性会覆盖前面的属性。并且会忽略enumerable属性为false的属性.看到这里我就想起了常用的new.")]),t._v(" "),e("h2",{attrs:{id:"内部实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内部实现"}},[t._v("#")]),t._v(" 内部实现")]),t._v(" "),e("p",[t._v("new的步骤是先创建空对象"),e("br"),t._v("\n空对象继承构造函数的prototype"),e("br"),t._v("\n用apply改变this指向让空对象执行构造函数并传递参数进来"),e("br"),t._v("\n然后判断如果result是对象并且不为空就返回result,如果不是对象就返回刚才的继承了protoype属性的空对象"),e("br"),t._v("\nes6官网的实现方法是这样的")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function _new(constructor,params){\n    var args = [].slice.call(arguments);\n    var constructor = args.shift();\n    var context = Object.create(constructor.prototype);\n    var result = constructor.apply(context,args);\n    return (typeof result==='object'&&result!=null)?result:context;\n}\n")])])]),e("p",[t._v("其中注意到Object.create这个是什么意思?Object.create会把参数当作生成的对象的模板,如果是prototype则新对象的protoype就被设置为这个参数,如果参数是个普通对象,那么就和普通对象的属性和方法相同.")])])}),[],!1,null,null,null);e.default=a.exports}}]);