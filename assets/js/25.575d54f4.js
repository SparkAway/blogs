(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{421:function(t,v,_){"use strict";_.r(v);var a=_(2),r=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),v("p",[t._v("24号闲来无事打了几局lol上单竟然没有对手，感觉很无聊所以不玩了，闲逛掘金发现一个大二实习面试的面经进去看了一眼发现一个问题是正则怎么匹配字符串里面的东西，正则之前也是学过但是也是百度东找找西找找，忘得也差不多了所以记录一下方便以后再随时查看学习"),v("br"),t._v(" "),v("em",[t._v("学习的文章来源地址是"),v("a",{attrs:{href:"https://juejin.cn/post/6844903845227659271",target:"_blank",rel:"noopener noreferrer"}},[v("OutboundLink")],1)])]),t._v(" "),v("h2",{attrs:{id:"正则表达式到底是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式到底是什么"}},[t._v("#")]),t._v(" 正则表达式到底是什么")]),t._v(" "),v("p",[t._v("正则表达式就是专门用来进行字符串模式匹配的，正则表达式基本组成元素为两个部分一个是字符一个是元字符，字符就是数字和字母，元字符是特殊字符表示一个特殊含义^表示非，|表示或")]),t._v(" "),v("h2",{attrs:{id:"单个字符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单个字符"}},[t._v("#")]),t._v(" 单个字符")]),t._v(" "),v("p",[t._v("若是匹配单个字符比如匹配a就用/a/，如果想匹配特殊字符比如*则必须用转义符\\放在*的前面还有一些特殊字符比如回车空格等")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("特殊字符")]),t._v(" "),v("th",[t._v("正则表达式")]),t._v(" "),v("th",[t._v("记忆的方式")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("换行符")]),t._v(" "),v("td",[t._v("\\n")]),t._v(" "),v("td",[t._v("new line")])]),t._v(" "),v("tr",[v("td",[t._v("回车")]),t._v(" "),v("td",[t._v("\\r")]),t._v(" "),v("td",[t._v("return")])]),t._v(" "),v("tr",[v("td",[t._v("空格")]),t._v(" "),v("td",[t._v("\\s")]),t._v(" "),v("td",[t._v("space")])]),t._v(" "),v("tr",[v("td",[t._v("换页")]),t._v(" "),v("td",[t._v("\\f")]),t._v(" "),v("td",[t._v("form feed")])]),t._v(" "),v("tr",[v("td",[t._v("制表")]),t._v(" "),v("td",[t._v("\\t")]),t._v(" "),v("td",[t._v("tab")])]),t._v(" "),v("tr",[v("td",[t._v("回退")]),t._v(" "),v("td",[t._v("[\\b]")]),t._v(" "),v("td",[t._v("backspace")])]),t._v(" "),v("tr",[v("td",[t._v("垂直制表符")]),t._v(" "),v("td",[t._v("\\v")]),t._v(" "),v("td",[t._v("vertical")])])])]),t._v(" "),v("p",[v("em",[t._v("回退用[]是因为要和\\b区分开来")])]),t._v(" "),v("h2",{attrs:{id:"多个字符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多个字符"}},[t._v("#")]),t._v(" 多个字符")]),t._v(" "),v("p",[t._v("多个字符用集合的方式[123]表示匹配1或者2或者3，比如匹配字母a到z /[a-z]/ 数字0-9 /[0-9]/"),v("br"),t._v("\n但是当多种组合在一起时这种方式也是低效的所以有很多的简便正则")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("匹配区间")]),t._v(" "),v("th",[t._v("正则表达式")]),t._v(" "),v("th",[t._v("记忆的方式")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("除了换行以外的任何字符")]),t._v(" "),v("td",[t._v(".")]),t._v(" "),v("td",[t._v("特殊记忆吧")])]),t._v(" "),v("tr",[v("td",[t._v("单个数字,[0-9]")]),t._v(" "),v("td",[t._v("\\d")]),t._v(" "),v("td",[t._v("digit")])]),t._v(" "),v("tr",[v("td",[t._v("除了[0-9]")]),t._v(" "),v("td",[t._v("\\D")]),t._v(" "),v("td",[t._v("not digit")])]),t._v(" "),v("tr",[v("td",[t._v("包括下划线在内的单个字符,[A-Za-z0-9")]),t._v(" "),v("td",[t._v("\\w")]),t._v(" "),v("td",[t._v("word")])]),t._v(" "),v("tr",[v("td",[t._v("非单字字符")]),t._v(" "),v("td",[t._v("\\W")]),t._v(" "),v("td",[t._v("not word")])]),t._v(" "),v("tr",[v("td",[t._v("匹配空白字符，包括空格，制表换页换行")]),t._v(" "),v("td",[t._v("[\\s]")]),t._v(" "),v("td",[t._v("space相关")])]),t._v(" "),v("tr",[v("td",[t._v("非空白")]),t._v(" "),v("td",[t._v("\\S")]),t._v(" "),v("td",[t._v("not space")])])])]),t._v(" "),v("h2",{attrs:{id:"循环和重复"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#循环和重复"}},[t._v("#")]),t._v(" 循环和重复")]),t._v(" "),v("p",[t._v("匹配多个字符需要用到循环和重复，根据循环重复次数分为 0次，1次，多次，指定次数")]),t._v(" "),v("h3",{attrs:{id:"_0-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0-1"}},[t._v("#")]),t._v(" 0|1")]),t._v(" "),v("p",[t._v("用?代表匹配一个或者0个字符 ，如color 和 colour都想都是匹配到 /colou?r/")]),t._v(" "),v("h3",{attrs:{id:"_0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0"}},[t._v("#")]),t._v(" >=0")]),t._v(" "),v("p",[t._v("用*表示0次或者无数次 ，通常用来过滤可有可无的字符串")]),t._v(" "),v("h3",{attrs:{id:"_1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[t._v("#")]),t._v(" >=1")]),t._v(" "),v("p",[t._v("用+表示1次或多次")]),t._v(" "),v("h3",{attrs:{id:"指定次数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指定次数"}},[t._v("#")]),t._v(" 指定次数")]),t._v(" "),v("p",[t._v("用{}"),v("br"),t._v("\n/a{3}/匹配3次"),v("br"),t._v("\n/a{2,}/至少两次"),v("br"),t._v("\n/a{2,4}/介于2次和4次之间"),v("br"),t._v("\n/a{0,4}/最多4次")]),t._v(" "),v("h2",{attrs:{id:"位置边界"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#位置边界"}},[t._v("#")]),t._v(" 位置边界")]),t._v(" "),v("p",[t._v("比如就想匹配单词的开头和结尾"),v("br"),t._v("\n比如想匹配一段话中的cat但是用/cat/会匹配到cat和 scattered两个单词所以需要用到边界\\b\n"),v("code",[t._v("The cat scattered his food all over the room")]),v("br"),t._v("\n/\\bcat\\b/以c开头t结尾中间是a的单词只有cat")]),t._v(" "),v("h2",{attrs:{id:"字符串边界"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字符串边界"}},[t._v("#")]),t._v(" 字符串边界")]),t._v(" "),v("p",[t._v("刚刚匹配的都是一个小单词，这是匹配一个长的字符串"),v("br"),t._v("\n用^匹配开始，以$表示结束"),v("br"),t._v("\n匹配 I am cxk000. 用/^I am cxk000\\.$/m 这个m是一个常用的标志意思是多行模式类似的如下")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("边界和标志")]),t._v(" "),v("th",[t._v("正则表达式")]),t._v(" "),v("th",[t._v("记忆方式")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("单词边界")]),t._v(" "),v("td",[t._v("\\b")]),t._v(" "),v("td",[t._v("boundary")])]),t._v(" "),v("tr",[v("td",[t._v("非单词边界")]),t._v(" "),v("td",[t._v("\\B")]),t._v(" "),v("td",[t._v("not boundary")])]),t._v(" "),v("tr",[v("td",[t._v("字符串开头")]),t._v(" "),v("td",[t._v("^")]),t._v(" "),v("td",[t._v("特殊记忆")])]),t._v(" "),v("tr",[v("td",[t._v("字符串结尾")]),t._v(" "),v("td",[t._v("$")]),t._v(" "),v("td",[t._v("特殊记忆")])]),t._v(" "),v("tr",[v("td",[t._v("多行模式")]),t._v(" "),v("td",[t._v("m标志")]),t._v(" "),v("td",[t._v("multiple of lines")])]),t._v(" "),v("tr",[v("td",[t._v("忽略大小写")]),t._v(" "),v("td",[t._v("i标志")]),t._v(" "),v("td",[t._v("ignore case,case-insensitive")])]),t._v(" "),v("tr",[v("td",[t._v("全局模式")]),t._v(" "),v("td",[t._v("g标志")]),t._v(" "),v("td",[t._v("not space")])])])]),t._v(" "),v("h2",{attrs:{id:"子表达式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#子表达式"}},[t._v("#")]),t._v(" 子表达式")]),t._v(" "),v("p",[t._v("上面都是些简单的字符匹配，下面是高级的用法子表达式"),v("br"),t._v("\n一般由简单到复杂的正则表达式通常通过分组，回溯引用，逻辑处理这三种来实现")]),t._v(" "),v("h3",{attrs:{id:"分组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分组"}},[t._v("#")]),t._v(" 分组")]),t._v(" "),v("p",[t._v("其中分组体现在：所有以(和)元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。")]),t._v(" "),v("h3",{attrs:{id:"回溯引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回溯引用"}},[t._v("#")]),t._v(" 回溯引用")]),t._v(" "),v("p",[t._v("所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像\\1,\\2,....,其中\\1表示引用的第一个子表达式，\\2表示引用的第二个子表达式，以此类推。而\\0则表示整个表达式。\n比如现在要在下面这个文本里匹配两个连续相同的单词\n"),v("code",[t._v("Hello what what is the first thing, and I am am scq000.")]),v("br"),t._v("\n利用回溯引用，我们可以很容易地写出/\\b(\\w+)\\s\\1/这样的正则。"),v("br"),t._v("\n回溯引用在替换字符串中十分常用，语法上有些许区别，用$1,$2...来引用要被替换的字符串。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("var str = 'abc abc 123';\nstr.replace(/(ab)c/g,'$1g');\n// 得到结果 'abg abg 123'\n")])])]),v("h3",{attrs:{id:"向前查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向前查找"}},[t._v("#")]),t._v(" 向前查找")]),t._v(" "),v("p",[t._v("前向查找(lookahead)是用来限制后缀的。凡是以(?=regex)包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如happy happily这两个单词，我想获得以happ开头的副词，那么就可以使用happ(?=ily)来匹配。如果我想过滤所有以happ开头的副词，那么也可以采用负前向查找的正则happ(?!ily)，就会匹配到happy单词的happ前缀。")]),t._v(" "),v("h3",{attrs:{id:"后向查找"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#后向查找"}},[t._v("#")]),t._v(" 后向查找")]),t._v(" "),v("p",[t._v("后向查找\n介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： apple和people都包含ple这个后缀，那么如果我只想找到apple的ple，该怎么做呢？我们可以通过限制app这个前缀，就能唯一确定ple这个单词了。\n/(?<=app)ple/复制代码其中(?<=regex)的语法就是我们这里要介绍的后向查找。regex指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向后查找。另外一种限制匹配是利用(?<!regex) 语法，这里称为负后向查找。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找apple的ple也可以这么写成/(?<!peo)ple。\n需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("回溯查找")]),t._v(" "),v("th",[t._v("正则表达式")]),t._v(" "),v("th",[t._v("记忆方式")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("引用")]),t._v(" "),v("td",[t._v("\\0,\\1,\\2 和 $0, $1, $2")]),t._v(" "),v("td",[t._v("转义+数字")])]),t._v(" "),v("tr",[v("td",[t._v("非捕获组")]),t._v(" "),v("td",[t._v("(?😃")]),t._v(" "),v("td",[t._v("引用表达式(()), 本身不被消费(?),引用(😃")])]),t._v(" "),v("tr",[v("td",[t._v("前向查找")]),t._v(" "),v("td",[t._v("(?=)")]),t._v(" "),v("td",[t._v("引用子表达式(())，本身不被消费(?), 正向的查找(=)")])]),t._v(" "),v("tr",[v("td",[t._v("前向负查找")]),t._v(" "),v("td",[t._v("(?!)")]),t._v(" "),v("td",[t._v("引用子表达式(())，本身不被消费(?), 负向的查找(!)")])]),t._v(" "),v("tr",[v("td",[t._v("后向查找")]),t._v(" "),v("td",[t._v("(?<=)")]),t._v(" "),v("td",[t._v("引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=)")])]),t._v(" "),v("tr",[v("td",[t._v("后向负查找")]),t._v(" "),v("td",[t._v("(?<!)")]),t._v(" "),v("td",[t._v("引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!)")])])])]),t._v(" "),v("h2",{attrs:{id:"逻辑处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#逻辑处理"}},[t._v("#")]),t._v(" 逻辑处理")]),t._v(" "),v("p",[t._v("计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。\n在正则里面，默认的正则规则都是与的关系所以这里不讨论。\n而非关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用^这个元字符。在这里要着重记忆一下：只有在[和]内部使用的^才表示非的关系。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式(?!regex)或后向负查找子表达式(?<!regex)。\n或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用(a|b)这样的子表达式。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("逻辑关系")]),t._v(" "),v("th",[t._v("正则元字符")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("与")]),t._v(" "),v("td",[t._v("无")])]),t._v(" "),v("tr",[v("td",[t._v("非")]),t._v(" "),v("td",[t._v("[^regex]和!")])]),t._v(" "),v("tr",[v("td",[t._v("或")]),t._v(" "),v("td",[t._v("|")])])])]),t._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("学到那个向前向后查找，有点难度而且有点复杂加上我有点烦了"),v("br"),t._v("\n今天看了两页git权威指南的书"),v("br"),t._v("\n粗略的学了一下正则表达式"),v("br"),t._v("\n看了一下关于怎么让cookie更安全，大致就是cookie存的信息本来暴露的风险就很大所以尽量不要把重要的放在cookie里面，并且开启httponly这样可以避免通过js和html操作cookie，还可以在服务器端存一个secret字段然后通过一个算法，比如(auth=true+secret字段)算法 = $gagaga 然后通过相应发给客户端，客户端只能看见auth=true&#gagaga却理解不了#gagaga因为不知道secret，下次伪造auth为别点信息的时候，服务器识别不了所以就不允许了。也可以设置更显的cookie作用域来限制")])])}),[],!1,null,null,null);v.default=r.exports}}]);